type Caregiver @pgTable(name: "caregivers") {
  # Unique row identifier.
  id: ID! @pgColumn(name: "row_id") @unique
  # Unique caregiver identifier.
  cgid: Int! @unique
  # Title of the caregiver, for example MD or RN.
  label: String
  # More detailed description of the caregiver, if available.
  description: String
  chartevents: [Chartevent]
  datetimeevents: [Datetimeevent]
  inputevents_cv: [Inputevents_cv]
  inputevents_mv: [Inputevents_mv]
  noteevents: [Noteevent]
  outputevents: [Outputevent]
  procedureevents_mv: [Procedureevents_mv]
}

type Admission @indexes(value: [
  {name: "admissions_idx02", fields: ["hadm_id"]}
]) @pgTable(name: "admissions") {
  # Unique row identifier.
  id: ID! @pgColumn(name: "row_id") @unique
  # Admission location.
  admission_location: String!
  # Type of admission, for example emergency or elective.
  admission_type: String!
  # Time of admission to the hospital.
  admittime: DateTime!
  callout: [Callout]
  chartevents: [Chartevent]
  cptevents: [Cptevent]
  datetimeevents: [Datetimeevent]
  # Time of death.
  deathtime: DateTime
  diagnoses_icd: [Diagnoses_icd]
  # Diagnosis.
  diagnosis: String
  # Discharge location
  discharge_location: String!
  # Time of discharge from the hospital.
  dischtime: DateTime!
  drgcodes: [Drgcode]
  edouttime: DateTime
  edregtime: DateTime
  # Ethnicity.
  ethnicity: String!
  # Primary key. Identifies the hospital stay.
  hadm_id: Int! @unique
  # Hospital admission has at least one observation in the CHARTEVENTS table.
  has_chartevents_data: Int!
  hospital_expire_flag: Int
  icustays: [Icustay]
  inputevents_cv: [Inputevents_cv]
  inputevents_mv: [Inputevents_mv]
  # Insurance type.
  insurance: String!
  labevents: [Labevent]
  # Language.
  language: String
  # Marital status.
  marital_status: String
  microbiologyevents: [Microbiologyevent]
  noteevents: [Noteevent]
  outputevents: [Outputevent]
  prescriptions: [Prescription]
  procedureevents_mv: [Procedureevents_mv]
  procedures_icd: [Procedures_icd]
  # Religon.
  religion: String
  services: [Service]
  transfers: [Transfer]
}

type Callout @pgTable(name: "callout") {
  # Unique row identifier.
  id: ID! @pgColumn(name: "row_id") @unique
  # The status of the response to the call out request.
  acknowledge_status: String!
  # Time at which the call out request was acknowledged.
  acknowledgetime: DateTime
  # The result of the call out request; either a cancellation or a discharge.
  callout_outcome: String!
  # Identifies the service that the patient is called out to.
  callout_service: String!
  # Current status of the call out request.
  callout_status: String!
  # Identifies the ward where the patient is to be discharged to. A value of 1 indicates the first available ward. A value of 0 indicates home.
  callout_wardid: Int
  # Time at which the call out request was created.
  createtime: DateTime!
  # If the ward where the patient is currently residing is an ICU, the ICU type is listed here.
  curr_careunit: String
  # Identifies the ward where the patient is currently residing.
  curr_wardid: Int
  # Latest time at which a ward was reserved for the call out request.
  currentreservationtime: DateTime
  # The ward to which the patient was discharged.
  discharge_wardid: Int
  # First time at which a ward was reserved for the call out request.
  firstreservationtime: DateTime
  # Time at which the outcome (cancelled or discharged) occurred.
  outcometime: DateTime!
  # Indicates if special precautions are required.
  request_cdiff: Int!
  # Indicates if special precautions are required.
  request_mrsa: Int!
  # Indicates if special precautions are required.
  request_resp: Int!
  # Indicates if special precautions are required.
  request_tele: Int!
  # Indicates if special precautions are required.
  request_vre: Int!
  # If the ward where the call was submitted was an ICU, the ICU type is listed here.
  submit_careunit: String
  # Identifies the ward where the call out request was submitted.
  submit_wardid: Int
  # Last time at which the call out request was updated.
  updatetime: DateTime!
}

type Chartevent @pgTable(name: "chartevents") {
  # Unique row identifier.
  id: ID! @pgColumn(name: "row_id") @unique
  # Time when the event occured.
  charttime: DateTime
  # Flag to highlight an error with the event.
  error: Int
  # Result status of lab data.
  resultstatus: String
  # Text string indicating the stopped status of an event (i.e. stopped, not stopped).
  stopped: String
  # Time when the event was recorded in the system.
  storetime: DateTime
  # Value of the event as a text string.
  value: String
  # Value of the event as a number.
  valuenum: Float
  # Unit of measurement.
  valueuom: String
  # Flag to highlight that the value has triggered a warning.
  warning: Int
}

type Chartevents_1 @indexes(value: [
  {name: "chartevents_1_idx01", fields: ["itemid"]}
]) @pgTable(name: "chartevents_1") {
  cgid: Int
  charttime: DateTime
  error: Int
  hadm_id: Int
  icustay_id: Int
  itemid: Int
  resultstatus: String
  row_id: Int!
  stopped: String
  storetime: DateTime
  subject_id: Int!
  value: String
  valuenum: Float
  valueuom: String
  warning: Int
}

type Chartevents_10 @indexes(value: [
  {name: "chartevents_10_idx01", fields: ["itemid"]}
]) @pgTable(name: "chartevents_10") {
  cgid: Int
  charttime: DateTime
  error: Int
  hadm_id: Int
  icustay_id: Int
  itemid: Int
  resultstatus: String
  row_id: Int!
  stopped: String
  storetime: DateTime
  subject_id: Int!
  value: String
  valuenum: Float
  valueuom: String
  warning: Int
}

type Chartevents_11 @indexes(value: [
  {name: "chartevents_11_idx01", fields: ["itemid"]}
]) @pgTable(name: "chartevents_11") {
  cgid: Int
  charttime: DateTime
  error: Int
  hadm_id: Int
  icustay_id: Int
  itemid: Int
  resultstatus: String
  row_id: Int!
  stopped: String
  storetime: DateTime
  subject_id: Int!
  value: String
  valuenum: Float
  valueuom: String
  warning: Int
}

type Chartevents_12 @indexes(value: [
  {name: "chartevents_12_idx01", fields: ["itemid"]}
]) @pgTable(name: "chartevents_12") {
  cgid: Int
  charttime: DateTime
  error: Int
  hadm_id: Int
  icustay_id: Int
  itemid: Int
  resultstatus: String
  row_id: Int!
  stopped: String
  storetime: DateTime
  subject_id: Int!
  value: String
  valuenum: Float
  valueuom: String
  warning: Int
}

type Chartevents_13 @indexes(value: [
  {name: "chartevents_13_idx01", fields: ["itemid"]}
]) @pgTable(name: "chartevents_13") {
  cgid: Int
  charttime: DateTime
  error: Int
  hadm_id: Int
  icustay_id: Int
  itemid: Int
  resultstatus: String
  row_id: Int!
  stopped: String
  storetime: DateTime
  subject_id: Int!
  value: String
  valuenum: Float
  valueuom: String
  warning: Int
}

type Chartevents_14 @indexes(value: [
  {name: "chartevents_14_idx01", fields: ["itemid"]}
]) @pgTable(name: "chartevents_14") {
  cgid: Int
  charttime: DateTime
  error: Int
  hadm_id: Int
  icustay_id: Int
  itemid: Int
  resultstatus: String
  row_id: Int!
  stopped: String
  storetime: DateTime
  subject_id: Int!
  value: String
  valuenum: Float
  valueuom: String
  warning: Int
}

type Chartevents_15 @indexes(value: [
  {name: "chartevents_15_idx01", fields: ["itemid"]}
]) @pgTable(name: "chartevents_15") {
  cgid: Int
  charttime: DateTime
  error: Int
  hadm_id: Int
  icustay_id: Int
  itemid: Int
  resultstatus: String
  row_id: Int!
  stopped: String
  storetime: DateTime
  subject_id: Int!
  value: String
  valuenum: Float
  valueuom: String
  warning: Int
}

type Chartevents_16 @indexes(value: [
  {name: "chartevents_16_idx01", fields: ["itemid"]}
]) @pgTable(name: "chartevents_16") {
  cgid: Int
  charttime: DateTime
  error: Int
  hadm_id: Int
  icustay_id: Int
  itemid: Int
  resultstatus: String
  row_id: Int!
  stopped: String
  storetime: DateTime
  subject_id: Int!
  value: String
  valuenum: Float
  valueuom: String
  warning: Int
}

type Chartevents_17 @indexes(value: [
  {name: "chartevents_17_idx01", fields: ["itemid"]}
]) @pgTable(name: "chartevents_17") {
  cgid: Int
  charttime: DateTime
  error: Int
  hadm_id: Int
  icustay_id: Int
  itemid: Int
  resultstatus: String
  row_id: Int!
  stopped: String
  storetime: DateTime
  subject_id: Int!
  value: String
  valuenum: Float
  valueuom: String
  warning: Int
}

type Chartevents_2 @indexes(value: [
  {name: "chartevents_2_idx01", fields: ["itemid"]}
]) @pgTable(name: "chartevents_2") {
  cgid: Int
  charttime: DateTime
  error: Int
  hadm_id: Int
  icustay_id: Int
  itemid: Int
  resultstatus: String
  row_id: Int!
  stopped: String
  storetime: DateTime
  subject_id: Int!
  value: String
  valuenum: Float
  valueuom: String
  warning: Int
}

type Chartevents_3 @indexes(value: [
  {name: "chartevents_3_idx01", fields: ["itemid"]}
]) @pgTable(name: "chartevents_3") {
  cgid: Int
  charttime: DateTime
  error: Int
  hadm_id: Int
  icustay_id: Int
  itemid: Int
  resultstatus: String
  row_id: Int!
  stopped: String
  storetime: DateTime
  subject_id: Int!
  value: String
  valuenum: Float
  valueuom: String
  warning: Int
}

type Chartevents_4 @indexes(value: [
  {name: "chartevents_4_idx01", fields: ["itemid"]}
]) @pgTable(name: "chartevents_4") {
  cgid: Int
  charttime: DateTime
  error: Int
  hadm_id: Int
  icustay_id: Int
  itemid: Int
  resultstatus: String
  row_id: Int!
  stopped: String
  storetime: DateTime
  subject_id: Int!
  value: String
  valuenum: Float
  valueuom: String
  warning: Int
}

type Chartevents_5 @indexes(value: [
  {name: "chartevents_5_idx01", fields: ["itemid"]}
]) @pgTable(name: "chartevents_5") {
  cgid: Int
  charttime: DateTime
  error: Int
  hadm_id: Int
  icustay_id: Int
  itemid: Int
  resultstatus: String
  row_id: Int!
  stopped: String
  storetime: DateTime
  subject_id: Int!
  value: String
  valuenum: Float
  valueuom: String
  warning: Int
}

type Chartevents_6 @indexes(value: [
  {name: "chartevents_6_idx01", fields: ["itemid"]}
]) @pgTable(name: "chartevents_6") {
  cgid: Int
  charttime: DateTime
  error: Int
  hadm_id: Int
  icustay_id: Int
  itemid: Int
  resultstatus: String
  row_id: Int!
  stopped: String
  storetime: DateTime
  subject_id: Int!
  value: String
  valuenum: Float
  valueuom: String
  warning: Int
}

type Chartevents_7 @indexes(value: [
  {name: "chartevents_7_idx01", fields: ["itemid"]}
]) @pgTable(name: "chartevents_7") {
  cgid: Int
  charttime: DateTime
  error: Int
  hadm_id: Int
  icustay_id: Int
  itemid: Int
  resultstatus: String
  row_id: Int!
  stopped: String
  storetime: DateTime
  subject_id: Int!
  value: String
  valuenum: Float
  valueuom: String
  warning: Int
}

type Chartevents_8 @indexes(value: [
  {name: "chartevents_8_idx01", fields: ["itemid"]}
]) @pgTable(name: "chartevents_8") {
  cgid: Int
  charttime: DateTime
  error: Int
  hadm_id: Int
  icustay_id: Int
  itemid: Int
  resultstatus: String
  row_id: Int!
  stopped: String
  storetime: DateTime
  subject_id: Int!
  value: String
  valuenum: Float
  valueuom: String
  warning: Int
}

type Chartevents_9 @indexes(value: [
  {name: "chartevents_9_idx01", fields: ["itemid"]}
]) @pgTable(name: "chartevents_9") {
  cgid: Int
  charttime: DateTime
  error: Int
  hadm_id: Int
  icustay_id: Int
  itemid: Int
  resultstatus: String
  row_id: Int!
  stopped: String
  storetime: DateTime
  subject_id: Int!
  value: String
  valuenum: Float
  valueuom: String
  warning: Int
}

type Cptevent @indexes(value: [
  {name: "cptevents_idx02", fields: ["cpt_cd"]}
]) @pgTable(name: "cptevents") {
  # Unique row identifier.
  id: ID! @pgColumn(name: "row_id") @unique
  # Date when the event occured, if available.
  chartdate: DateTime
  # Center recording the code, for example the ICU or the respiratory unit.
  costcenter: String!
  # Current Procedural Terminology code.
  cpt_cd: String!
  # Numerical element of the Current Procedural Terminology code.
  cpt_number: Int
  # Text element of the Current Procedural Terminology, if any. Indicates code category.
  cpt_suffix: String
  # Description of the Current Procedural Terminology, if available.
  description: String
  # High-level section of the Current Procedural Terminology code.
  sectionheader: String
  # Subsection of the Current Procedural Terminology code.
  subsectionheader: String
  # Sequence number of the event, derived from the ticket ID.
  ticket_id_seq: Int
}

type D_cpt @pgTable(name: "d_cpt") {
  # Unique row identifier.
  id: ID! @pgColumn(name: "row_id") @unique
  # Code category.
  category: Int!
  # Text element of the Current Procedural Terminology, if any.
  codesuffix: String
  # Maximum code within the subsection.
  maxcodeinsubsection: Int!
  # Minimum code within the subsection.
  mincodeinsubsection: Int!
  # Section header.
  sectionheader: String!
  # Range of codes within the high-level section.
  sectionrange: String!
  # Subsection header.
  subsectionheader: String!
  # Range of codes within the subsection.
  subsectionrange: String! @unique
}

type D_icd_diagnosis @indexes(value: [
  {name: "d_icd_diag_idx01", fields: ["icd9_code"]},
  {name: "d_icd_diag_idx02", fields: ["long_title"]}
]) @pgTable(name: "d_icd_diagnoses") {
  # Unique row identifier.
  id: ID! @pgColumn(name: "row_id") @unique
  # ICD9 code - note that this is a fixed length character field, as whitespaces are important in uniquely identifying ICD-9 codes.
  icd9_code: String! @unique
  # Long title associated with the code.
  long_title: String!
  # Short title associated with the code.
  short_title: String!
}

type D_icd_procedure @indexes(value: [
  {name: "d_icd_proc_idx01", fields: ["icd9_code"]},
  {name: "d_icd_proc_idx02", fields: ["long_title"]}
]) @pgTable(name: "d_icd_procedures") {
  # Unique row identifier.
  id: ID! @pgColumn(name: "row_id") @unique
  # ICD9 code - note that this is a fixed length character field, as whitespaces are important in uniquely identifying ICD-9 codes.
  icd9_code: String! @unique
  # Long title associated with the code.
  long_title: String!
  # Short title associated with the code.
  short_title: String!
}

type D_item @indexes(value: [
  {name: "d_items_idx01", fields: ["itemid"]},
  {name: "d_items_idx02", fields: ["label"]}
]) @pgTable(name: "d_items") {
  # Unique row identifier.
  id: ID! @pgColumn(name: "row_id") @unique
  # Abbreviation associated with the item.
  abbreviation: String
  # Category of data which the concept falls under.
  category: String
  chartevents: [Chartevent]
  # Identifier used to harmonize concepts identified by multiple ITEMIDs. CONCEPTIDs are planned but not yet implemented (all values are NULL).
  conceptid: Int
  datetimeevents: [Datetimeevent]
  # Source database of the item.
  dbsource: String
  inputevents_mv: [Inputevents_mv]
  # Primary key. Identifies the charted item.
  itemid: Int! @unique
  # Label identifying the item.
  label: String
  # Table which contains data for the given ITEMID.
  linksto: String
  microbiologyevents: [Microbiologyevent]
  #microbiologyevents: [Microbiologyevent]
  #microbiologyevents: [Microbiologyevent]
  outputevents: [Outputevent]
  # Type of item, for example solution or ingredient.
  param_type: String
  procedureevents_mv: [Procedureevents_mv]
  # Unit associated with the item.
  unitname: String
}

type D_labitem @indexes(value: [
  {name: "d_labitems_idx01", fields: ["itemid"]},
  {name: "d_labitems_idx02", fields: ["label"]},
  {name: "d_labitems_idx03", fields: ["loinc_code"]}
]) @pgTable(name: "d_labitems") {
  # Unique row identifier.
  id: ID! @pgColumn(name: "row_id") @unique
  # Category of item, for example chemistry or hematology.
  category: String!
  # Fluid associated with the item, for example blood or urine.
  fluid: String!
  # Foreign key. Identifies the charted item.
  itemid: Int! @unique
  # Label identifying the item.
  label: String!
  labevents: [Labevent]
  # Logical Observation Identifiers Names and Codes (LOINC) mapped to the item, if available.
  loinc_code: String
}

type Datetimeevent @pgTable(name: "datetimeevents") {
  # Unique row identifier.
  id: ID! @pgColumn(name: "row_id") @unique
  # Time when the event occured.
  charttime: DateTime!
  # Flag to highlight an error with the event.
  error: Int
  # Result status of lab data.
  resultstatus: String
  # Event was explicitly marked as stopped. Infrequently used by caregivers.
  stopped: String
  # Time when the event was recorded in the system.
  storetime: DateTime!
  # Value of the event as a text string.
  value: DateTime
  # Unit of measurement.
  valueuom: String!
  # Flag to highlight that the value has triggered a warning.
  warning: Int
}

type Diagnoses_icd @indexes(value: [
  {name: "diagnoses_icd_idx02", fields: ["icd9_code"]}
]) @pgTable(name: "diagnoses_icd") {
  # Unique row identifier.
  id: ID! @pgColumn(name: "row_id") @unique
  # ICD9 code for the diagnosis.
  icd9_code: String
  # Priority of the code. Sequence 1 is the primary code.
  seq_num: Int
}

type Drgcode @indexes(value: [
  {name: "drgcodes_idx02", fields: ["drg_code"]},
  {name: "drgcodes_idx03", fields: ["description"]}
]) @pgTable(name: "drgcodes") {
  # Unique row identifier.
  id: ID! @pgColumn(name: "row_id") @unique
  # Description of the Diagnosis-Related Group
  description: String
  # Diagnosis-Related Group code
  drg_code: String!
  # Relative mortality, available for type APR only.
  drg_mortality: Int
  # Relative severity, available for type APR only.
  drg_severity: Int
  # Type of Diagnosis-Related Group, for example APR is All Patient Refined
  drg_type: String!
}

type Icustay @indexes(value: [
  {name: "icustays_idx02", fields: ["icustay_id"]}
]) @pgTable(name: "icustays") {
  # Unique row identifier.
  id: ID! @pgColumn(name: "row_id") @unique
  chartevents: [Chartevent]
  datetimeevents: [Datetimeevent]
  # Source database of the item.
  dbsource: String!
  # First careunit associated with the ICU stay.
  first_careunit: String!
  # Identifier for the first ward the patient was located in.
  first_wardid: Int!
  # Primary key. Identifies the ICU stay.
  icustay_id: Int! @unique
  inputevents_cv: [Inputevents_cv]
  inputevents_mv: [Inputevents_mv]
  # Time of admission to the ICU.
  intime: DateTime!
  # Last careunit associated with the ICU stay.
  last_careunit: String!
  # Identifier for the last ward the patient is located in.
  last_wardid: Int!
  # Length of stay in the ICU measured in fractional days.
  los: Float
  outputevents: [Outputevent]
  # Time of discharge from the ICU.
  outtime: DateTime
  prescriptions: [Prescription]
  procedureevents_mv: [Procedureevents_mv]
  transfers: [Transfer]
}

type Inputevents_cv @indexes(value: [
  {name: "inputevents_cv_idx04", fields: ["charttime"]},
  {name: "inputevents_cv_idx05", fields: ["itemid"]}
]) @pgTable(name: "inputevents_cv") {
  # Unique row identifier.
  id: ID! @pgColumn(name: "row_id") @unique
  # Amount of the item administered to the patient.
  amount: Float
  # Unit of measurement for the amount.
  amountuom: String
  # Time that the input was started or received.
  charttime: DateTime
  # Foreign key. Identifies the charted item.
  itemid: Int
  # Identifier linking orders across multiple administrations. LINKORDERID is always equal to the first occuring ORDERID of the series.
  linkorderid: Int
  # Indicates when a new bottle of the solution was hung at the bedside.
  newbottle: Int
  # Identifier linking items which are grouped in a solution.
  orderid: Int
  # Amount of the item which was originally charted.
  originalamount: Float
  # Unit of measurement for the original amount.
  originalamountuom: String
  # Rate of administration originally chosen for the item.
  originalrate: Float
  # Unit of measurement for the rate originally chosen.
  originalrateuom: String
  # Route of administration originally chosen for the item.
  originalroute: String
  # Anatomical site for the original administration of the item.
  originalsite: String
  # Rate at which the item is being administered to the patient.
  rate: Float
  # Unit of measurement for the rate.
  rateuom: String
  # Event was explicitly marked as stopped. Infrequently used by caregivers.
  stopped: String
  # Time when the event was recorded in the system.
  storetime: DateTime
}

type Inputevents_mv @pgTable(name: "inputevents_mv") {
  # Unique row identifier.
  id: ID! @pgColumn(name: "row_id") @unique
  # Amount of the item administered to the patient.
  amount: Float
  # Unit of measurement for the amount.
  amountuom: String
  # Reason for cancellation, if cancelled.
  cancelreason: Int
  # The title of the caregiver who canceled the order.
  comments_canceledby: String
  # Time at which the caregiver edited or cancelled the order.
  comments_date: DateTime
  # The title of the caregiver who edited the order.
  comments_editedby: String
  # Indicates whether the item will be continued in the next department where the patient is transferred to.
  continueinnextdept: Int
  # Time when the event ended.
  endtime: DateTime
  # Indicates whether the bag containing the solution is open.
  isopenbag: Int
  # Identifier linking orders across multiple administrations. LINKORDERID is always equal to the first occuring ORDERID of the series.
  linkorderid: Int
  # The type of item administered.
  ordercategorydescription: String
  # A group which the item corresponds to.
  ordercategoryname: String
  # The role of the item administered in the order.
  ordercomponenttypedescription: String
  # Identifier linking items which are grouped in a solution.
  orderid: Int
  # Amount of the item which was originally charted.
  originalamount: Float
  # Rate of administration originally chosen for the item.
  originalrate: Float
  # For drugs dosed by weight, the value of the weight used in the calculation.
  patientweight: Float
  # Rate at which the item is being administered to the patient.
  rate: Float
  # Unit of measurement for the rate.
  rateuom: String
  # A secondary group for those items with more than one grouping possible.
  secondaryordercategoryname: String
  # Time when the event started.
  starttime: DateTime
  # The current status of the order: stopped, rewritten, running or cancelled.
  statusdescription: String
  # Time when the event was recorded in the system.
  storetime: DateTime
  # The total amount in the solution for the given item.
  totalamount: Float
  # Unit of measurement for the total amount in the solution.
  totalamountuom: String
}

type Labevent @pgTable(name: "labevents") {
  # Unique row identifier.
  id: ID! @pgColumn(name: "row_id") @unique
  # Time when the event occured.
  charttime: DateTime
  # Flag indicating whether the lab test value is considered abnormal (null if the test was normal).
  flag: String
  # Value of the event as a text string.
  value: String
  # Value of the event as a number.
  valuenum: Float
  # Unit of measurement.
  valueuom: String
}

type Microbiologyevent @pgTable(name: "microbiologyevents") {
  # Unique row identifier.
  id: ID! @pgColumn(name: "row_id") @unique
  # Name of the antibody used.
  ab_name: String
  # Date when the event occured.
  chartdate: DateTime
  # Time when the event occured, if available.
  charttime: DateTime
  # The comparison component of DILUTION_TEXT: either <= (less than or equal), = (equal), or >= (greater than or equal), or null when not available.
  dilution_comparison: String
  # The dilution amount tested for and the comparison which was made against it (e.g. <=4).
  dilution_text: String
  # The value component of DILUTION_TEXT: must be a floating point number.
  dilution_value: Float
  # Interpretation of the test.
  interpretation: String
  # Isolate number associated with the test.
  isolate_num: Int
  # Name of the organism.
  org_name: String
  # Description of the specimen.
  spec_type_desc: String
}

type Noteevent @indexes(value: [
  {name: "noteevents_idx05", fields: ["category"]}
]) @pgTable(name: "noteevents") {
  # Unique row identifier.
  id: ID! @pgColumn(name: "row_id") @unique
  # Category of the note, e.g. Discharge summary.
  category: String
  # Date when the note was charted.
  chartdate: DateTime
  # Date and time when the note was charted. Note that some notes (e.g. discharge summaries) do not have a time associated with them: these notes have NULL in this column.
  charttime: DateTime
  # A more detailed categorization for the note, sometimes entered by free-text.
  description: String
  # Flag to highlight an error with the note.
  iserror: String
  storetime: DateTime
  # Content of the note.
  text: String
}

type Outputevent @pgTable(name: "outputevents") {
  # Unique row identifier.
  id: ID! @pgColumn(name: "row_id") @unique
  # Time when the output was recorded/occurred.
  charttime: DateTime
  # Flag to highlight an error with the measurement.
  iserror: Int
  # Not applicable to outputs - column always null.
  newbottle: String
  # Event was explicitly marked as stopped. Infrequently used by caregivers.
  stopped: String
  # Time when the event was recorded in the system.
  storetime: DateTime
  # Value of the event as a float.
  value: Float
  # Unit of measurement.
  valueuom: String
}

type Patient @pgTable(name: "patients") {
  # Unique row identifier.
  id: ID! @pgColumn(name: "row_id") @unique
  admissions: [Admission]
  callout: [Callout]
  chartevents: [Chartevent]
  cptevents: [Cptevent]
  datetimeevents: [Datetimeevent]
  diagnoses_icd: [Diagnoses_icd]
  # Date of birth.
  dob: DateTime!
  # Date of death. Null if the patient was alive at least 90 days post hospital discharge.
  dod: DateTime
  # Date of death recorded in the hospital records.
  dod_hosp: DateTime
  # Date of death recorded in the social security records.
  dod_ssn: DateTime
  drgcodes: [Drgcode]
  # Flag indicating that the patient has died.
  expire_flag: Int!
  # Gender.
  gender: String!
  icustays: [Icustay]
  inputevents_cv: [Inputevents_cv]
  inputevents_mv: [Inputevents_mv]
  labevents: [Labevent]
  microbiologyevents: [Microbiologyevent]
  noteevents: [Noteevent]
  outputevents: [Outputevent]
  prescriptions: [Prescription]
  procedureevents_mv: [Procedureevents_mv]
  procedures_icd: [Procedures_icd]
  services: [Service]
  # Primary key. Identifies the patient.
  subject_id: Int! @unique
  transfers: [Transfer]
}

type Prescription @indexes(value: [
  {name: "prescriptions_idx03", fields: ["drug_type"]},
  {name: "prescriptions_idx04", fields: ["drug"]}
]) @pgTable(name: "prescriptions") {
  # Unique row identifier.
  id: ID! @pgColumn(name: "row_id") @unique
  # Unit of measurement associated with the dose.
  dose_unit_rx: String
  # Dose of the drug prescribed.
  dose_val_rx: String
  # Name of the drug.
  drug: String!
  # Generic drug name.
  drug_name_generic: String
  # Name of the drug on the Provider Order Entry interface.
  drug_name_poe: String
  # Type of drug.
  drug_type: String!
  # Date when the prescription ended.
  enddate: DateTime
  # Unit of measurement associated with the formulation.
  form_unit_disp: String
  # Amount of the formulation dispensed.
  form_val_disp: String
  # Formulary drug code.
  formulary_drug_cd: String
  # Generic Sequence Number.
  gsn: String
  # National Drug Code.
  ndc: String
  # Strength of the drug (product).
  prod_strength: String
  # Route of administration, for example intravenous or oral.
  route: String
  # Date when the prescription started.
  startdate: DateTime
}

type Procedureevents_mv @pgTable(name: "procedureevents_mv") {
  id: ID! @pgColumn(name: "row_id") @unique
  cancelreason: Int
  comments_canceledby: String
  comments_date: DateTime
  comments_editedby: String
  continueinnextdept: Int
  endtime: DateTime
  isopenbag: Int
  linkorderid: Int
  location: String
  locationcategory: String
  ordercategorydescription: String
  ordercategoryname: String
  orderid: Int
  secondaryordercategoryname: String
  starttime: DateTime
  statusdescription: String
  storetime: DateTime
  value: Float
  valueuom: String
}

type Procedures_icd @indexes(value: [
  {name: "procedures_icd_idx02", fields: ["icd9_code"]}
]) @pgTable(name: "procedures_icd") {
  # Unique row identifier.
  id: ID! @pgColumn(name: "row_id") @unique
  # ICD9 code associated with the procedure.
  icd9_code: String!
  # Lower procedure numbers occurred earlier.
  seq_num: Int!
}

type Service @pgTable(name: "services") {
  # Unique row identifier.
  id: ID! @pgColumn(name: "row_id") @unique
  # Current service type.
  curr_service: String
  # Previous service type.
  prev_service: String
  # Time when the transfer occured.
  transfertime: DateTime!
}

type Transfer @pgTable(name: "transfers") {
  # Unique row identifier.
  id: ID! @pgColumn(name: "row_id") @unique
  # Current careunit.
  curr_careunit: String
  # Identifier for the current ward the patient is located in.
  curr_wardid: Int
  # Source database of the item.
  dbsource: String
  # Type of event, for example admission or transfer.
  eventtype: String
  # Time when the patient was transferred into the unit.
  intime: DateTime
  # Length of stay in the unit in minutes.
  los: Float
  # Time when the patient was transferred out of the unit.
  outtime: DateTime
  # Previous careunit.
  prev_careunit: String
  # Identifier for the previous ward the patient was located in.
  prev_wardid: Int
}
